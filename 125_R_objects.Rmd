<!-- 
This file by Martin Monkman 
is licensed under a Creative Commons Attribution 4.0 International License
https://creativecommons.org/licenses/by/4.0/  
-->

# R objects {#R_objects}

```{r echo = FALSE}
library(knitr)
opts_chunk$set(message = FALSE, warning = FALSE, cache = TRUE)
options(width = 100, dplyr.width = 100)
```


## Examining the data

When we import a dataframe into a spreadsheet or other data analysis tool, we immediately _see_ the data. In Excel, the Gapminder dataset looks like this:

![gapminder spreadsheet](static/img/excel_gapminder_2.JPG)

Like the crew of the Enterprise, we get the data "On screen!" so we can visually investigate it.


![_"On screen!"_](static/img/gapminder_STNG_onscreen_x.png)



#### _Looking_ at data

In R, when we load a dataframe:

* we assign it to an object

* and that object shows up in our Environment pane.


![_gapminder in RStudio_](static/img/gapminder_RStudio_2.JPG)

This is a different view of the universe.



In R, there are a few options for visually scanning your data:


| function | description |  
|||  
|*Content: * | |
|`head()` | shows the first rows; the default is 6 |
|`tail()` | shows the last rows; the default is 6 | 
|`view()` or `View()`| display in tab |


***


In addition to visually inspecting the data, there are also other functions to understand a dataframe:

| function | description |  
|||  
|*Size:*  | |
|`dim()` | returns a vector with the number of rows as the first element, and the number of columns as the second element (the dimensions of the object) |
|`nrow()` | returns the number of rows |
|`ncol()` | returns the number of columns |


Functions to understand the contents of your dataframe:

| function | description |  
|||  
|*Names:* | |
|`names()` | returns the column names (synonym of colnames() for data.frame objects) |
|*Summary:* | |
|`ls()` | returns the names in a specified environment or object  |
|`str()` | structure of the object and information about the class, length and content of each column |
| `ls.str()` | combines `ls()` and `str()`| 
|`summary()` | summary statistics for each column |
|`glimpse()` | returns the number of columns and rows of the tibble, the names and class of each column, and previews as many values will fit on the screen. Unlike the other inspecting functions listed above, glimpse() is not a “base R” function so you need to have the dplyr or tibble packages loaded to be able to execute it. |

Note: most of these functions are “generic.” They can be used on other types of objects besides dataframes or tibbles.  



## Variable types 

In R (as with other programming languages), data is stored as different variable types. In a spreadsheet program like Excel this is obscured from the user, but in R it's explicit, and in many contexts, it matters.

`int` stands for integers.

`dbl` stands for doubles, or real numbers.

`chr` stands for character vectors, or strings.

`date` stands for dates.

`dttm` stands for date-times (a date + a time).

`fctr` stands for factors, which R uses to represent categorical variables with fixed possible values.


`lgl` stands for logical, vectors that contain only TRUE or FALSE.


### Missing values `NA` 

`NA` are explicitly missing values.

* they can be included as any type: e.g. numeric or character


> See [_R for Data Science_, "Data transformation: Missing values](https://r4ds.had.co.nz/transform.html#missing-values)


Missing values are _contagious_

* an `NA` in the input will return an `NA` in the output

Three simple examples:

```{r}
1 + NA
```

```{r}
num_list <- c(1, 2, NA, 4, 5)
1 + num_list
```

```{r}
mean(num_list)
```



Or a longer example...

This data has multiple NAs in the "displ_mean" column.

`displ_class_by_cyl`

```{r echo=FALSE}
# summary table - class by cylinder
displ_class_by_cyl <- mpg %>%
  group_by(class, cyl) %>%
  summarise(displ_mean = mean(displ)) %>%
  arrange(desc(displ_mean)) %>%
  pivot_wider(names_from = cyl, values_from = displ_mean) %>%
  pivot_longer(-class, names_to = "cyl", values_to = "displ_mean")

displ_class_by_cyl

```


What happens when we calculate the mean of "displ_mean"?

```{r}
mean(displ_class_by_cyl$displ_mean)
```


The solution:

`na.rm` removes `NA`s from the calculation

```{r}
mean(displ_class_by_cyl$displ_mean, na.rm = TRUE)
```



## Functions for missing values

Dealing with those pesky `NA` values  

| function | action |
| : --  | : |
| `is.na(x)` | returns TRUE or FALSE for each value in `x` |
| `anyNA(x)` | returns a single TRUE or FALSE |
| `na.rm = TRUE` | remove `NA` values when running function|



```{r}
x <- c(1, NA, 3)

is.na(x)
```




# Data Wrangling

Filtering and selecting

Adding variables

Reshaping

Cleaning







# Part 1: {dplyr} -


![dplyr hex](../../static/img/dplyr_400.png)


> The [{dplyr} site](https://dplyr.tidyverse.org/index.html)


***

> Please refer to [_R for Data Science_, Data transformation](https://r4ds.had.co.nz/transform.html) for more information about this section.

When working with data, particularly large data sets, you encounter a situation where you need to: 

* subset the data so that it contains only those _records_ (rows) you are interested in (Why deal with a data table that has every province in Canada when you just need the British Columbia data?)

* subset the data so that it contains only those _variables_ (columns) you are interested in (Why keep looking at variables that do not factor into your analysis, or you will not print in your report?)

* create new variables, often through calculations based on variables in your data



To achieve these three goals, we will be using functions from the tidyverse package {dplyr}. The functions are verbs that describe what they do. Here's a list of the {dplyr} functions that you'll be using:


|function |action |
| : | : |
| `filter()`    | *keep rows*|
| `select()`    | *keep variables (or drop them -var)*|
| `mutate()`    | *create a new variable*|
| `arrange()`    | *sort from smallest to largest*|
| `arrange(desc())`    | *sort from largest to smallest*|



### other operators

In addition to these functions, R has a number of operators that add significantly to your code.

**Arithmetic operators**

| Operator | Description |
| : | : |
| + | *plus* |
| - | *minus* |
| \* | *multiplication*  |
| / | *division* |
| ^ | *exponential* |

<P>

**Boolean operators** are a special type of operator that return TRUE or FALSE.  

| Operator | Description |
| : | : |
| ==    | *equal, tests equality* |
| !=    | *not equal, tests inequality* |
| \>    | *greater than, tests greater than* (also >=) |
| <     | *less than, tests less than* (also <=) |
| %in%  | *contains, tests inclusion* |

<P>

Boolean operators can be combined with *and* or *or*.  

| Operator | Description |
| : | : |
| `&`     | *and, returns true if preceding and following are both true, else false* |
| &#124;  | *or, returns true if either preceding and following are true, else false* |


> see [_R for Data Science_, "Comparisions"](https://r4ds.had.co.nz/transform.html#comparisons) and ["Logical Operators"](https://r4ds.had.co.nz/transform.html#logical-operators).]


## The Pipe Operator


### Introducing the pipe operator ` %>% `

(see [_R for Data Science_, Pipes](https://r4ds.had.co.nz/pipes.html) for a deep dive into pipes)

The pipe operator ` %>% ` allows us to name the data frame first, and then have other functions work with the outcome of the first line.

For example, we could write

`function(data, arg)` 

or, with a pipe

`data %>% function(arg)` 

Read the pipe symbol as "then".  We start with our data, _then_ we apply the function.

If we want to do anything with the output from the first statement, we have to assign it to an intermediate object, and then use that intermediate object in the second statement. With the pipe, we can simply add another pipe and the results of the first function are passed to the second statement.

As we get to increasingly complex statements, the power of this will become more evident.


### Lists

### Creating lists

R allows us to create lists using the `c()` function.

A list can be referenced in a `filter()` statement using the `%in%` as the evaluator.

In this example, we filter to get three countries, "New Zealand", "Canada", and "United States".

Note that to get all three, the statement is _OR_, not _AND_! There are no cases where `country == "New Zealand"` and simultaneously `country == "Canada"` ... 

```{r}

gapminder %>% 
  filter(country == "New Zealand" |
           country == "Canada" |
           country == "United States")

```

Instead of this rather verbose syntax, we can achieve the same result by creating a list. 


```{r filter6_example-solution}
# answer
gapminder %>%
  filter(country %in% c("New Zealand", "Canada", "United States"))

```

Another option would be to create a named object that contains our list, and then use the named object in our `filter()`


```{r}
  
# alternate answer
country_list <- c("New Zealand", "Canada", "United States")   # create object that is list of countries

gapminder %>%
  filter(country %in% country_list)                           # filter uses that object 
  

```







## {dplyr} functions are verbs


|function |action |
| : | : |
| `filter()`    | *keep rows*|
| `mutate()`    | *create a new variable*|
| `group_by()`  | *declare subsets in data*|
| `select()`    | *keep variables (or drop them -var)*|
| `rename()`    | *renaming variables*|
| `summarize()` | *summarize the data, by groups if they have been declared*|
| `tally()`     | *counting (by groups if group_by() applied)*|
| `distinct()`  | *returns only rows that are unique*| 
| `case_when()` | *is used for "recoding" variable, often used with mutate()*|


???

Source: Gina Reynolds,[Tidyverse in Action](https://github.com/EvaMaeRey/tidyverse_in_action)

* with modifications by Martin Monkman



## Arithmetic operators

| Operator | Description |
| : -- | : |
| + | *plus* |
| - | *minus* |
| \* | *multiplication*  |
| / | *division* |
| ^ | *exponential* |

???

Source: Gina Reynolds,[Tidyverse in Action](https://github.com/EvaMaeRey/tidyverse_in_action)




## Boolean operators

Boolean operators are a special type of operator that return TRUE or FALSE.  

| Operator | Description |
| : -- | : |
| ==    | *equal, tests equality* |
| !=    | *not equal, tests inequality* |
| \>    | *greater than, tests greater than* (also >=) |
| <     | *less than, tests less than* (also <=) |
| %in%  | *contains, tests inclusion* |


???

Source: Gina Reynolds,[Tidyverse in Action](https://github.com/EvaMaeRey/tidyverse_in_action)




Boolean operators can be combined with *and* or *or*.  

| Operator | Description |
| : -- | : |
| `&`     | *and, returns true if preceeding and following are both true, else false* |
| &#124;  | *or, returns true if either preceeding and following are true, else false* |

.footnote[see [_R for Data Science_, "Comparisions""](https://r4ds.had.co.nz/transform.html#comparisons) and ["Logical Operators"](https://r4ds.had.co.nz/transform.html#logical-operators).]





## Useful functions

Some basic statistical functions  

| Operator | Description |
| : -- | : |
| `min()` <br> `max()` | *minimum and maximum values* |
| `mean()` <br> `median()` <br> `mode()` | *measures of "average"* |
| `sum()`  | *adds up the values* |
| `length` <br> `dplyr::count()`  | *number of cases* |
| `summary()`  | *a list of measures of central tendency* |






# `summarize`

_or_ `summarise`!

```{r}
mpg %>%
  summarise(minYear = min(year), maxYear = max(year))

```




# a summary table

`group_by()` to define the summary grouping

`arrange()` to have things in ascending order

* modify with `desc()` for descending order


```{r eval=FALSE}
mpg %>%                                       
  group_by(class) %>%                         
  summarise(displ_mean = mean(displ)) %>%     
  arrange(desc(displ_mean))                   
```




```{r}
mpg %>%                                       
  group_by(class) %>%                         
  summarise(displ_mean = mean(displ)) %>%     
  arrange(desc(displ_mean))                   
```



## create new variables

`mutate()`

You can calculate new variables that may be useful in your analysis

### _vectors of the same length_

```{r}

mpg <- mpg %>%
  mutate(mpg_per_cubic_litre = hwy / displ)

```



### _vector of the length = 1_

* convert miles per US gallon to litres per 100 kilometers

```{r}
# calculate conversion constant
lp100km <- (100 * 3.785) / (1.61)
lp100km
# divide constant by hwy mpg to get hwy litres per 100 km
mpg %>%
  mutate(hwy_lp100km = lp100km / hwy)

```



the `summary()` function gives you a range of measures of central tendency
 
```{r}

summary(mpg$hwy)

```



# Part 2 - {tidyr} -


![tidyr hex](../../static/img/tidyr_400.png)

The [{tidyr} site](https://tidyr.tidyverse.org/)



Slide deck:

Julie Lowndes & Allison Horst, [Make friends with tidy data](https://docs.google.com/presentation/d/1N7hKepabvl9OrHjvGJWPjUsfzVdB5xzV5AsFndgSwms/edit#slide=id.p)




A pivot table crosstab using the {mpg} data package of automobile fuel economy.

First, a look at the source table.





Using `group_by` and `summarise` to create a summary table of the average engine displacement:

```{r}
mpg %>%                                
  group_by(class) %>%                   
  summarise(displ_mean = mean(displ)) 

```



Now do the same with vehicle class and number of cylinders:

```{r}

class_by_cyl <- mpg %>%
  group_by(class, cyl) %>%
  summarise(mean = mean(displ)) %>%
  arrange(desc(mean))

class_by_cyl

```




What happens if you reverse the order of the grouping variables?



Create a pivot (crosstab) table with class by number of cylinders:


using `pivot_wider()`

```{r}
class_by_cyl_pivot <- class_by_cyl %>%
  pivot_wider(names_from = cyl, values_from = mean)


class_by_cyl_pivot
```



# and back to longer...

```{r}

class_by_cyl_pivot %>%
  pivot_longer(-class, names_to = "cyl", values_to = "mean")

```




Note that `pivot_wider()` and `pivot_longer()` are new functions, introduced in 2019.

The older {tidyr} functions that do the same thing: `spread()` and `gather()`.

For example, `spread()` to replicate the `pivot_wider()` function:

```{r}

class_by_cyl %>%
  spread(cyl, value = mean)

```



More about tidy data:

* ["Tidy Data" chapter](https://r4ds.had.co.nz/tidy-data.html) in _R4DS_.

* ["Tidy Data for Efficiency, Reproducibility, and Collaboration"](https://www.openscapes.org/blog/2020/10/12/tidy-data/))




## Manipulate variables 
##(back to {dplyr})

You've already seen `mutate()` to calculate new variables for your dataframe. What if you want to remove some variables?



Using `select()` to reduce the number of variables:

```{r}
library(gapminder)

gapminder %>%                                
  select(country, year, lifeExp) 

```




You can use the minus sign to drop variable--that is, to define ones to _not_ select. 

In this example, note we have to use `c()` to create a list:

```{r}
gapminder %>%                                
  select(-c(continent, pop, gdpPercap))

```




You can define a range of columns to select:

```{r}
gapminder %>%
  select(country, year:pop)
```



## Summarize (or Summarise)


## Summary statistics

R has a built-in function to generate some summary statistics. The first is `summary()` which gives a few key statistics about the distribution.


```{r}

summary(gapminder)

```


These statistics can all be generated individually, using the functions in the table below. Other statistical measures about a variable can be calculated with the appropriate function. Note that these are just a few of the functions that are included in base R; there are also other statistical measures available through various packages.


 | statistic | function |
 | ----       | ----      |
 | mean      | `mean()`   |
 | median   | `median()` |
 | mode | `mode()`  |
 | minimum and maximum | `min()`  `max()`  |
 | range | `range()`  |
 |  &#8212;  | &#8212;  |
 | sum | `sum()` |
 | count (number of cases) | `length()`  |
 | standard deviation | `sd()` |
 | variance  | `var()` |
 | kurtosis | `kurtosis()` |
 | skewness | `skewness()` |
 | correlation coefficient | `cor()` |
  
 
 
 This code calculates the mean of life expectancy
 
```{r}

mean(gapminder$lifeExp)

```


Another way to do this would be using the pipe operator. The symbol is `%>%` and links one line of script to the next. The way to read this is as meaning "and then..."

At this point, we only have one step in our chain, but in future code, you might have multiple steps linked one after the other.

So this little chunk would be read as

* we start with the datafram "exp_dem", "and then..."

* we calculate a variable called "mean_of_expense" by running the `mean()` function on the variable "Expense"

```{r}

gapminder %>% 
  summarise(mean_of_life_expectancy = mean(lifeExp))

```


### Arguments within functions

Virtually every function we use has default arguments, and options to change those. This allows us to use one function for a variety of circumstances. Instead of having separate functions to split a variable into its quartiles (four parts), quintiles (five parts), deciles (ten parts), and so on, there is one function that uses the generic name for this process: quantile. 

The default setting of the `quantile()` function splits the distribution into four parts—_quartiles_. This is the most common quantile used to summarize a distribution.

```{r}

quantile(gapminder$lifeExp)

```


If you want other groupings, the function has arguments that allow you define those. For example, if you want deciles—10 groups, each with 10% of the cases—the second example shows how to do that.


```{r}


# deciles
quantile(gapminder$lifeExp, probs = seq(0, 1, 0.10))

```
