<!-- 
This file by Martin Monkman 
is licensed under a Creative Commons Attribution 4.0 International License
https://creativecommons.org/licenses/by/4.0/  

The tables of functions are modified from originals by Gina Reynolds,[Tidyverse in Action](https://github.com/EvaMaeRey/tidyverse_in_action)

-->

```{r echo = FALSE}
library(knitr)
opts_chunk$set(message = FALSE, warning = FALSE, cache = TRUE)
options(width = 100, dplyr.width = 100)
```

# Introduction to data wrangling {#data_wrangle}


```{r echo = FALSE}

library(tidyverse)
library(gapminder)
```



## Data wrangling

Data is abundant, and as data analysts we often have to spend time working with our data tables to get it ready for whatever analysis we need to do. "Data wrangling" and "data transformation" are two terms that are used to describe the process of altering the structure of our data.^["Data cleaning" is a whole other thingâ€”we will encounter that later.] 

There are three broad categories of data transformation:

- altering the structure of the existing data tables. This could be through adding or removing rows or columns to our data table, including calculation of new variables, or importation of additional rows (observations) and joining two tables together.

- summarizing the content of the source data tables. For example, if our data table has the population of all the countries in the world, we might want a summary table that has the table with the total for each continent.

- with both our existing data or our summary tables, we may want it in a different layout, either for analysis purposes or to make it easier for human readers to absorb the information.

In this section, we will begin to work with all three transformations.


### Reading

* [_R for Data Science_, Data transformation](https://r4ds.had.co.nz/transform.html)



## Part 1: `{dplyr}` -


![dplyr hex](static/img/dplyr_400.png)


> The [{dplyr} site](https://dplyr.tidyverse.org/index.html)


***

> Please refer to [_R for Data Science_, Data transformation](https://r4ds.had.co.nz/transform.html) for more information about this section.

When working with data, particularly large data sets, you encounter a situation where you need to: 

* subset the data so that it contains only those _records_ (rows) you are interested in (Why deal with a data table that has every province in Canada when you just need the British Columbia data?)

* subset the data so that it contains only those _variables_ (columns) you are interested in (Why keep looking at variables that do not factor into your analysis, or you will not print in your report?)

* create new variables, often through calculations based on variables in your data



To achieve these three goals, we will be using functions from the tidyverse package {dplyr}. The functions are verbs that describe what they do. Here's a list of the {dplyr} functions that you'll be using:


|function |action |
| : | : |
| `filter()`    | *keep rows*|
| `select()`    | *keep variables (or drop them -var)*|
| `mutate()`    | *create a new variable*|
| `arrange()`    | *sort from smallest to largest*|
| `arrange(desc())`    | *sort from largest to smallest*|



### other operators

In addition to these functions, R has a number of operators that add significantly to your code.

**Arithmetic operators**

| Operator | Description |
| : | : |
| + | *plus* |
| - | *minus* |
| \* | *multiplication*  |
| / | *division* |
| ^ | *exponential* |

<P>

**Boolean operators** are a special type of operator that return TRUE or FALSE.  

| Operator | Description |
| : | : |
| ==    | *equal, tests equality* |
| !=    | *not equal, tests inequality* |
| \>    | *greater than, tests greater than* (also >=) |
| <     | *less than, tests less than* (also <=) |
| %in%  | *contains, tests inclusion* |

<P>

Boolean operators can be combined with *and* or *or*.  

| Operator | Description |
| : | : |
| `&`     | *and, returns true if preceding and following are both true, else false* |
| &#124;  | *or, returns true if either preceding and following are true, else false* |


> see [_R for Data Science_, "Comparisions"](https://r4ds.had.co.nz/transform.html#comparisons) and ["Logical Operators"](https://r4ds.had.co.nz/transform.html#logical-operators).]




### Introducing the pipe operator ` %>% `

(see [_R for Data Science_, Pipes](https://r4ds.had.co.nz/pipes.html) for a deep dive into pipes)

The pipe operator ` %>% ` allows us to name the data frame first, and then have other functions work with the outcome of the first line.

For example, we could write

`function(data, arg)` 

or, with a pipe

`data %>% function(arg)` 

Read the pipe symbol as "then".  We start with our data, _then_ we apply the function.

If we want to do anything with the output from the first statement, we have to assign it to an intermediate object, and then use that intermediate object in the second statement. With the pipe, we can simply add another pipe and the results of the first function are passed to the second statement.

As we get to increasingly complex statements, the power of this will become more evident.


### Creating lists

R allows us to create lists using the `c()` function.

A list can be referenced in a `filter()` statement using the `%in%` as the evaluator.

In this example, we filter to get three countries, "New Zealand", "Canada", and "United States".

Note that to get all three, the statement is _OR_, not _AND_! There are no cases where `country == "New Zealand"` and simultaneously `country == "Canada"` ... 

```{r}

gapminder %>% 
  filter(country == "New Zealand" |
           country == "Canada" |
           country == "United States")

```

Instead of this rather verbose syntax, we can achieve the same result by creating a list. 


```{r filter6_example-solution}
# answer
gapminder %>%
  filter(country %in% c("New Zealand", "Canada", "United States"))

```

Another option would be to create a named object that contains our list, and then use the named object in our `filter()`


```{r}
  
# alternate answer
country_list <- c("New Zealand", "Canada", "United States")   # create object that is list of countries

gapminder %>%
  filter(country %in% country_list)                           # filter uses that object 
  

```







## {dplyr} functions are verbs


|function |action |
| : | : |
| `filter()`    | *keep rows*|
| `mutate()`    | *create a new variable*|
| `group_by()`  | *declare subsets in data*|
| `select()`    | *keep variables (or drop them -var)*|
| `rename()`    | *renaming variables*|
| `summarize()` | *summarize the data, by groups if they have been declared*|
| `tally()`     | *counting (by groups if group_by() applied)*|
| `distinct()`  | *returns only rows that are unique*| 
| `case_when()` | *is used for "recoding" variable, often used with mutate()*|




## Arithmetic operators

| Operator | Description |
| : -- | : |
| + | *plus* |
| - | *minus* |
| \* | *multiplication*  |
| / | *division* |
| ^ | *exponential* |

???

Source: Gina Reynolds,[Tidyverse in Action](https://github.com/EvaMaeRey/tidyverse_in_action)




## Boolean operators

Boolean operators are a special type of operator that return TRUE or FALSE.  

| Operator | Description |
| : -- | : |
| ==    | *equal, tests equality* |
| !=    | *not equal, tests inequality* |
| \>    | *greater than, tests greater than* (also >=) |
| <     | *less than, tests less than* (also <=) |
| %in%  | *contains, tests inclusion* |


???

Source: Gina Reynolds,[Tidyverse in Action](https://github.com/EvaMaeRey/tidyverse_in_action)




Boolean operators can be combined with *and* or *or*.  

| Operator | Description |
| : -- | : |
| `&`     | *and, returns true if preceeding and following are both true, else false* |
| &#124;  | *or, returns true if either preceeding and following are true, else false* |

.footnote[see [_R for Data Science_, "Comparisions""](https://r4ds.had.co.nz/transform.html#comparisons) and ["Logical Operators"](https://r4ds.had.co.nz/transform.html#logical-operators).]





## Useful functions

Some basic statistical functions  

| Operator | Description |
| : -- | : |
| `min()` <br> `max()` | *minimum and maximum values* |
| `mean()` <br> `median()` <br> `mode()` | *measures of "average"* |
| `sum()`  | *adds up the values* |
| `length` <br> `dplyr::count()`  | *number of cases* |
| `summary()`  | *a list of measures of central tendency* |






## `summarize`

_or_ `summarise`!

```{r}
mpg %>%
  summarise(minYear = min(year), maxYear = max(year))

```




#### a summary table

`group_by()` to define the summary grouping

`arrange()` to have things in ascending order

* modify with `desc()` for descending order


```{r eval=FALSE}
mpg %>%                                       
  group_by(class) %>%                         
  summarise(displ_mean = mean(displ)) %>%     
  arrange(desc(displ_mean))                   
```




```{r}
mpg %>%                                       
  group_by(class) %>%                         
  summarise(displ_mean = mean(displ)) %>%     
  arrange(desc(displ_mean))                   
```



## create new variables

`mutate()`

You can calculate new variables that may be useful in your analysis

_vectors of the same length_

```{r}

mpg <- mpg %>%
  mutate(mpg_per_cubic_litre = hwy / displ)

```



_vector of the length = 1_

* convert miles per US gallon to litres per 100 kilometers

```{r}
# calculate conversion constant
lp100km <- (100 * 3.785) / (1.61)
lp100km
# divide constant by hwy mpg to get hwy litres per 100 km
mpg %>%
  mutate(hwy_lp100km = lp100km / hwy)

```



the `summary()` function gives you a range of measures of central tendency
 
```{r}

summary(mpg$hwy)

```



## Part 2 - `{tidyr}` -


![tidyr hex](static/img/tidyr_400.png)

The [{tidyr} site](https://tidyr.tidyverse.org/)



Slide deck:

Julie Lowndes & Allison Horst, [Make friends with tidy data](https://docs.google.com/presentation/d/1N7hKepabvl9OrHjvGJWPjUsfzVdB5xzV5AsFndgSwms/edit#slide=id.p)




A pivot table crosstab using the {mpg} data package of automobile fuel economy.

First, a look at the source table.





Using `group_by` and `summarise` to create a summary table of the average engine displacement:

```{r}
mpg %>%                                
  group_by(class) %>%                   
  summarise(displ_mean = mean(displ)) 

```



Now do the same with vehicle class and number of cylinders:

```{r}

class_by_cyl <- mpg %>%
  group_by(class, cyl) %>%
  summarise(mean = mean(displ)) %>%
  arrange(desc(mean))

class_by_cyl

```




What happens if you reverse the order of the grouping variables?



Create a pivot (crosstab) table with class by number of cylinders:


using `pivot_wider()`

```{r}
class_by_cyl_pivot <- class_by_cyl %>%
  pivot_wider(names_from = cyl, values_from = mean)


class_by_cyl_pivot
```



### and back to longer...

```{r}

class_by_cyl_pivot %>%
  pivot_longer(-class, names_to = "cyl", values_to = "mean")

```




Note that `pivot_wider()` and `pivot_longer()` are new functions, introduced in 2019.

The older {tidyr} functions that do the same thing: `spread()` and `gather()`.

For example, `spread()` to replicate the `pivot_wider()` function:

```{r}

class_by_cyl %>%
  spread(cyl, value = mean)

```



More about tidy data:

* ["Tidy Data" chapter](https://r4ds.had.co.nz/tidy-data.html) in _R4DS_.

* ["Tidy Data for Efficiency, Reproducibility, and Collaboration"](https://www.openscapes.org/blog/2020/10/12/tidy-data/))




## Manipulate variables 

(back to {dplyr})

You've already seen `mutate()` to calculate new variables for your dataframe. What if you want to remove some variables?



Using `select()` to reduce the number of variables:

```{r}
library(gapminder)

gapminder %>%                                
  select(country, year, lifeExp) 

```




You can use the minus sign to drop variable--that is, to define ones to _not_ select. 

In this example, note we have to use `c()` to create a list:

```{r}
gapminder %>%                                
  select(-c(continent, pop, gdpPercap))

```




You can define a range of columns to select:

```{r}
gapminder %>%
  select(country, year:pop)
```



## Summary statistics

R has a built-in function to generate some summary statistics. The first is `summary()` which gives a few key statistics about the distribution.


```{r}

summary(gapminder)

```


These statistics can all be generated individually, using the functions in the table below. Other statistical measures about a variable can be calculated with the appropriate function. Note that these are just a few of the functions that are included in base R; there are also other statistical measures available through various packages.


 | statistic | function |
 | ----       | ----      |
 | mean      | `mean()`   |
 | median   | `median()` |
 | mode | `mode()`  |
 | minimum and maximum | `min()`  `max()`  |
 | range | `range()`  |
 |  &#8212;  | &#8212;  |
 | sum | `sum()` |
 | count (number of cases) | `length()`  |
 | standard deviation | `sd()` |
 | variance  | `var()` |
 | kurtosis | `kurtosis()` |
 | skewness | `skewness()` |
 | correlation coefficient | `cor()` |
  
 
 
 This code calculates the mean of life expectancy
 
```{r}

mean(gapminder$lifeExp)

```


Another way to do this would be using the pipe operator. The symbol is `%>%` and links one line of script to the next. The way to read this is as meaning "and then..."

At this point, we only have one step in our chain, but in future code, you might have multiple steps linked one after the other.

So this little chunk would be read as

* we start with the datafram "exp_dem", "and then..."

* we calculate a variable called "mean_of_expense" by running the `mean()` function on the variable "Expense"

```{r}

gapminder %>% 
  summarise(mean_of_life_expectancy = mean(lifeExp))

```


### Arguments within functions

Virtually every function we use has default arguments, and options to change those. This allows us to use one function for a variety of circumstances. Instead of having separate functions to split a variable into its quartiles (four parts), quintiles (five parts), deciles (ten parts), and so on, there is one function that uses the generic name for this process: quantile. 

The default setting of the `quantile()` function splits the distribution into four partsâ€”_quartiles_. This is the most common quantile used to summarize a distribution.

```{r}

quantile(gapminder$lifeExp)

```


If you want other groupings, the function has arguments that allow you define those. For example, if you want decilesâ€”10 groups, each with 10% of the casesâ€”the second example shows how to do that.


```{r}


# deciles
quantile(gapminder$lifeExp, probs = seq(0, 1, 0.10))

```


## Exercise

[Transform data](https://monkmanmh.shinyapps.io/BIDA302_1-2_transform_data/#section-transform-data-1a-manipulate-cases)


-30-

## Data wrangling

Data is abundant, and as data analysts we often have to spend time working with our data tables to get it ready for whatever analysis we need to do. "Data wrangling" and "data transformation" are two terms that are used to describe the process of altering the structure of our data.^["Data cleaning" is a whole other thingâ€”we will encounter that later.] 

There are three broad categories of data transformation:

- altering the structure of the existing data tables. This could be through adding or removing rows or columns to our data table, including calculation of new variables, or importation of additional rows (observations) and joining two tables together.

- summarizing the content of the source data tables. For example, if our data table has the population of all the countries in the world, we might want a summary table that has the table with the total for each continent.

- with both our existing data or our summary tables, we may want it in a different layout, either for analysis purposes or to make it easier for human readers to absorb the information.

In this section, we will begin to work with all three transformations.


### Reading

* [_R for Data Science_, Data transformation](https://r4ds.had.co.nz/transform.html)



